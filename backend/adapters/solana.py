import json
from dotenv import load_dotenv
import os
import hashlib
from datetime import datetime, timezone
from typing import Dict, Any, Optional

from solana.rpc.api import Client
from solana.rpc.core import RPCException

from solders.keypair import Keypair
from solders.pubkey import Pubkey
from solders.instruction import Instruction
from solders.transaction import Transaction

from data.solana_anchor_models import AnchorRecord

load_dotenv()
# -------------------------
# In-memory store
# -------------------------
ANCHOR_STORE: Dict[str, AnchorRecord] = {}


# -------------------------
# Hashing helper
# -------------------------
def compute_plan_hash(plan: Dict[str, Any]) -> str:
    """
    Deterministic hash of a plan JSON.
    sort_keys=True ensures same hash for same content.
    """
    plan_str = json.dumps(plan, sort_keys=True, separators=(",", ":"))
    return hashlib.sha256(plan_str.encode("utf-8")).hexdigest()


# -------------------------
# Solana client + fee payer setup
# -------------------------

def _load_fee_payer_from_file(path: str) -> Keypair:
    """
    Load a Solana keypair from a standard Solana JSON keypair file
    (the one generated by `solana-keygen new`).
    """
    with open(path, "r", encoding="utf-8") as f:
        secret_key_list = json.load(f)
    # solana-keygen file is an array of 64 bytes
    secret_key_bytes = bytes(secret_key_list)
    return Keypair.from_bytes(secret_key_bytes)


def _init_solana_client_and_keypair():
    rpc_url = os.getenv("SOLANA_RPC_URL", "https://api.devnet.solana.com")
    keypair_path = os.getenv("SOLANA_KEYPAIR_PATH")

    if not keypair_path:
        raise RuntimeError(
            "SOLANA_KEYPAIR_PATH env var is not set. "
            "Set it to the path of a solana-keygen JSON keypair file."
        )

    client = Client(rpc_url)
    fee_payer = _load_fee_payer_from_file(keypair_path)

    return client, fee_payer


# Initialize once at import time
try:
    SOLANA_CLIENT, FEE_PAYER = _init_solana_client_and_keypair()
    print("âœ… Solana fee payer pubkey:", FEE_PAYER.pubkey())
    # Memo program public key
    MEMO_PROGRAM_ID = Pubkey.from_string("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr")
except Exception as e:
    raise RuntimeError(f"Failed to initialize Solana client or keypair: {e}") from e


# -------------------------
# Real Solana anchoring
# -------------------------

def anchor_plan_on_solana(session_id: str, plan_record: Dict[str, Any]) -> AnchorRecord:
    plan_hash = compute_plan_hash(plan_record)

    # Optionally keep the balance check if you added it:
    # _check_fee_payer_balance()

    # 1. Build memo instruction with plan_hash as UTF-8 bytes
    memo_data = plan_hash.encode("utf-8")
    instruction = Instruction(
        program_id=MEMO_PROGRAM_ID,
        accounts=[],
        data=memo_data,
    )

    # 2. Get a recent blockhash
    try:
        latest_blockhash_resp: GetLatestBlockhashResp = SOLANA_CLIENT.get_latest_blockhash()
    except Exception as ex:
        raise RuntimeError(f"Failed to fetch latest blockhash from Solana: {ex}") from ex

    latest_blockhash = latest_blockhash_resp.value.blockhash

    # 3. Build and sign transaction
    tx = Transaction.new_signed_with_payer(
        [instruction],
        FEE_PAYER.pubkey(),
        [FEE_PAYER],
        latest_blockhash,
    )

    # 4. Send transaction
    try:
        send_resp: SendTransactionResp = SOLANA_CLIENT.send_transaction(tx)
    except RPCException as rpc_err:
        raise RuntimeError(f"Solana RPCException while sending transaction: {rpc_err}") from rpc_err
    except Exception as ex:
        raise RuntimeError(f"Unexpected error while sending Solana transaction: {ex}") from ex

    # 5. Extract tx signature (Signature -> str)
    tx_sig_obj = send_resp.value  # this is a Signature object
    tx_sig = str(tx_sig_obj)      # convert to base58 string

    record = AnchorRecord(
        session_id=session_id,
        plan_hash=plan_hash,
        solana_tx=tx_sig,
        anchored_at=datetime.now(timezone.utc),
    )
    ANCHOR_STORE[session_id] = record
    return record



def get_anchor(session_id: str) -> Optional[AnchorRecord]:
    """
    Retrieve an existing anchor record by session_id.
    """
    return ANCHOR_STORE.get(session_id)


def make_hardcoded_plan(session_id: str = "session-123") -> Dict[str, Any]:
    """
    Hardcoded synthetic negotiation plan.
    This simulates the output of your AI/ML + DID negotiation pipeline.
    """
    return {
        "session_id": session_id,
        "driver_did": "did:itn:user-abc",
        "vehicle_did": "did:itn:vehicle-xyz",
        "charger_did": "did:itn:charger-001",
        "site_id": "site-helsinki-hq",
        "created_at": datetime.now(timezone.utc).isoformat(),
        "constraints": {
            "leave_by": "2025-11-14T15:00:00Z",
            "min_soc": 0.7,
            "current_soc": 0.4,
            "battery_capacity_kwh": 60.0,
            "grid_constrained_until": "2025-11-14T13:00:00Z",
            "max_power_kw": 11,
            "priority": "normal",
        },
        "plan": {
            "phases": [
                {
                    "phase": 1,
                    "from": "2025-11-14T11:05:00Z",
                    "to": "2025-11-14T13:00:00Z",
                    "power_kw": 3.0,
                    "reason": "Grid constrained, slow charge",
                },
                {
                    "phase": 2,
                    "from": "2025-11-14T13:00:00Z",
                    "to": "2025-11-14T14:30:00Z",
                    "power_kw": 11.0,
                    "reason": "Grid OK, fast top-up",
                },
            ],
            "expected_soc_at_departure": 0.72,
        },
        "ai_metadata": {
            "planner_version": "v0.1",
            "forecast_model": "simple_regression_v1",
            "explanation_summary": (
                "Slow charging until 13:00 due to grid stress, "
                "then full power to reach ~72% by 14:30."
            ),
        },
        "denso_vc_refs": {
            "vehicle_vc_id": "urn:uuid:vehicle-vc-123",
            "charger_vc_id": "urn:uuid:charger-vc-456",
            "user_vc_id": "urn:uuid:user-vc-789",
            "negotiated_plan_vc_id": "urn:uuid:plan-vc-000",
        },
    }